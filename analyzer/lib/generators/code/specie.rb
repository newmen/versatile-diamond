module VersatileDiamond
  using Patches::RichString

  module Generators
    module Code

      # Creates Specie class
      # The species code which will be generated by this class should be topological
      # sorted, because in method #generate builds all necessary symmetric presentation
      # of specie
      class Specie < CppClassWithGen
        include PartialRenderer
        include PolynameClass
        include EnumerableOutFile # should be after PolynameClass

        attr_reader :spec, :anchors
        attr_reader :spec_links # for species comparator

        # Initialize specie code generator
        # @param [EngineCode] generator see at #super same argument
        # @param [Organizers::DependentSpec] spec source file for which will be
        #   generated
        def initialize(generator, spec)
          super(generator)
          @spec = spec
          @_class_name, @_enum_name, @_used_iterators = nil

          @spec_links = propertize_links(spec)
          @all_props = spec_links.keys

          @rest_links = spec.rest && propertize_links(spec.rest)
          @anchors = links.keys

          @_atoms_delta, @_props_sequence = nil
        end

        # @override
        def generate(root_dir)
          if symmetric?
            original = OriginalSpecie.new(@generator, self)
            symmetrics = @symmetrics.map do |indexes_hash|

              SymmetricSpecie.new(@generator, original)
            end

            original.generate(root_dir)
            # - три шаблона: original_specie, symmetric_specie, find algorithms
            # - создавая симметрию проверять нужна ли она, по потомкам
            # - original_specie полностью делигирует на текущий specie, кроме метода
            #   render_find_algorithms?
          else
            super
          end

          # если в родительской структуре используются симметричные атомы, то в
          # алгоритмы поиска подставлять итерацию каждой симметрии
        end

        # Finds self symmetrics by children species which are uses symmetric atoms of
        # current specie. Should be called from generator after than all specie class
        # renderers will be created.
        def find_self_symmetrics!
          @symmetrics = []
          children.each do |child|
            intersec = intersec_with(child)
binding.pry

            # intersec must be found in any case
            unless intersec.first.size == spec_links.size
              raise "Correct intersec wasn't found"
            end

            filtered_intersec = child.filter_intersections(intersec)
            next if filtered_intersec.size == 1

            binding.pry if spec.name == :bridge

            major_intersec = filtered_intersec.shift
            reset_all_atoms(major_intersec.map(&:first))

            filtered_intersec.each do |insec|
              @symmetrics << insec unless @symmetrics.include?(insec)
            end
          end
        end

        # Is symmetric specie? If children species uses same as own atom and it atom
        # has symmetric analogy
        #
        # @return [Boolean] is symmetric specie or not
        def symmetric?
          !@symmetrics.empty?
        end

# FROM HERE <<<<<<<<<<<<<<<<<<<<<<<<<

        # Detects additional atoms which are not presented in parent species
        # @return [Array] the array of additional atoms
        def addition_props
          adds = parents.reduce(@all_props) do |acc, parent|
            acc - parent.props_sequence
          end
          sort_props(adds)
        end

        # Makes general sequence of atoms which will be used for get an atom index
        # @return [Array] the general sequence of atoms of current specie
        def props_sequence
          @_props_sequence ||=
            if parents.size == 0
              sort_props(@all_props)
            else
              result = atoms_delta > 0 ? addition_props : []
              parents.reduce(result) { |acc, parent| acc + parent.props_sequence }
            end
        end

        # Gets an index of some atom
        # @return [Concepts::Atom | Concepts::AtomReference | Concepts::SpecificAtom]
        #   atom for which index will be got from general sequence
        # @return [Integer] the index of atom in general sequence
        def atom_index(atom)
          props_sequence.index(atom)
        end

# TO HERE >>>>>>>>>>>>>>>>>>>>>>>>>>>>>

        [
          ['class', :classify, ''],
          ['enum', :upcase, '_']
        ].each do |name, method, separator|
          method_name = :"#{name}_name"
          var_name = :"@_#{method_name}"

          # Makes #{name} name for current specie
          # @return [String] the result #{name} name
          define_method(method_name) do
            var = instance_variable_get(var_name)
            return var if var

            m = spec.name.to_s.match(/(\w+)(\(.+?\))?/)
            addition = "#{separator}#{name_suffixes(m[2]).join(separator)}" if m[2]
            instance_variable_set(var_name, "#{m[1].send(method)}#{addition}")
          end
        end

        # Gets number of sceleton atoms used in specie and different from atoms of
        # parent specie
        #
        # @return [Integer] the number of atoms
        # TODO: must be private
        def atoms_num
          links.size
        end

      protected

        # Filters intersections with parent specie. Checks that anchors points to
        # different atoms of parent specie.
        #
        # @param [Array] intersec the array of intersections with parent specie
        # @return [Array] the array of filtered intersections
        def filter_intersections(intersec)
          result = []
          collector = [] # stores unique pairs of anchors from intersec
          intersec.each do |insec|
            mirror = insec.invert
            new_collection = Set.new

            anchors.each do |atom|
              parent_atom = mirror[atom]
              unless new_collection.include?(parent_atom)
                new_collection << [atom, parent_atom]
              end
            end

            unless collector.include?(new_collection)
              collector << new_collection
              result << insec
            end
          end
          result
        end

        # Resets the internal atom sequence
        def reset_sequence
          @_props_sequence = nil
          children.each { |c| c.reset_sequence }
        end

      private

        # Specie class has find algorithms by default
        # @return [Boolean] true
        def render_find_algorithms?
          return true
        end

        # Gets target links between different atoms
        # @return [Hash] the links between atoms
        def links
          @rest_links || spec_links
        end

        # Remakes the links and exchanges all atoms to correspond atom properties
        # @param [Organizers::DependentBaseSpec | Organizers::DependentSpecificSpec |
        #   Organizers::SpecResidual] spec links of which will be propertized
        # @return [Hash] the links between atom properties
        def propertize_links(spec)
          result = spec.links.map do |atom, list|
            prop = Organizers::AtomProperties.new(spec, atom)
            updated_list = list.map do |a, relation|
              pr = spec.links[a] && Organizers::AtomProperties.new(spec, a)
              if !pr && atom.reference?
                dep_spec = Organizers::DependentBaseSpec.new(atom.spec)
                binding.pry
                pr = Organizers::AtomProperties.new(dep_spec, a)
              end
              raise 'Incorrect property' unless pr
              [pr, relation]
            end
            [prop, updated_list]
          end
          Hash[result]
        end

        # Finds intersec with some another specie
        # @param [Specie] child of current specie with which intersec will be found
        # @return [Array] the array of all possible intersec
        def intersec_with(child)
          args = [self, child, { collaps_multi_bond: true, method: :spec_links }]
          insec = SpeciesComparator.intersec(*args) do |_, _, self_prop, child_prop|
            self_prop.contained_in?(child_prop) ? (puts 'yes'; true) : false
          end
          binding.pry
          insec.map { |ins| Hash[ins.to_a] }
        end

        # Sets the atoms from passed list and drops the internal cache
        # @param [Array] atoms the list of all atoms where new anchors of specie
        #   renderer will be selected
        def reset_all_atoms(atoms)
          @all_props = atoms
          reset_sequence
        end

        # Reverse sorts the props by number of their relations
        # @param [Array] props the array of sorting props
        # @return [Array] sorted array of props
        def sort_props(props)
          props.sort_by { |pr| -spec_links[pr].size }
        end

        # Counts delta between atoms num of current specie and sum of atoms num of
        # all parents
        #
        # @return [Integer] the delta between atoms nums
        def atoms_delta
          return @_atoms_delta if @_atoms_delta
          plss = parents.map(&:spec).map(&:links).map(&:size).reduce(:+)
          @_atoms_delta = spec.links.size - (plss || 0)
        end

        # Gets the parent specie classes
        # @return [Array] the array of parent specie class generators
        def parents
          prs = spec.is_a?(Organizers::DependentBaseSpec) ?
            spec.parents : (spec.parent ? [spec.parent] : [])
          prs.map(&method(:specie_class))
        end

        # Gets the children specie classes
        # @return [Array] the array of children specie class generators
        def children
          spec.children.uniq.reject(&:termination?).map(&method(:specie_class))
        end

        # Checks that specie have children
        # @return [Boolean] is parent or not
        def parent?
          !spec.children.empty?
        end

        # Checks that specie have reactions
        # @return [Boolean] is specific or not
        def specific?
          !spec.reactions.empty?
        end

        # Checks that specie have there objects
        # @return [Boolean] is lateral or not
        def lateral?
          !spec.theres.empty?
        end

        # Makes base classes string for current specie class instance
        # @return [String] combined base classes of engine framework
        def base_classes_str
          "public #{wrapped_base_class}#{iterator_classes_str}"
        end

        # Combines base engine templated specie classes
        # @return [String] unwrapped combined base engine template classes
        def base_engine_class_name
          base_class = parent? ? 'ParentSpec' : 'BaseSpec'
          parents_num = parents.size
          parents_num == 0 ?
            "SourceSpec<#{base_class}, #{atoms_num}>" :
            "DependentSpec<#{base_class}, #{parents_num}>"
        end

        # Checks that specie contain additional atoms and if truth then wraps base
        # class name
        #
        # @return [String] the wrapped or not base engine class name
        def wrapped_engine_class_name
          base_class = base_engine_class_name
          delta = atoms_delta
          delta > 0 ? "AdditionalAtomsWrapper<#{base_class}, #{delta}>" : base_class
        end

        # Wraps combined base engine class by classes which works with handbook
        # @return [String] full major base class
        def wrapped_base_class
          base = "Base<#{wrapped_engine_class_name}, #{enum_name}, #{atoms_num}>"
          base = "Specific<#{base}>" if specific?
          base = "Sidepiece<#{base}>" if lateral?
          base
        end

        # Gets outer template name of base class
        # @return [String] the outer base class name
        def outer_base_class
          lateral? ? 'Sidepiece' : (specific? ? 'Specific' : 'Base')
        end

        # Gets outer template name of base class
        # @return [String] the outer base class name
        def outer_base_file
          outer_base_class.underscore
        end

        # Makes string by which base constructor will be called
        # @return [String] the string with calling base constructor
        def outer_base_call
          params = constructor_arguments.map(&:last).join(', ')
          "#{outer_base_class}(#{params})"
        end

        # Gets the collection of used crystal atom iterator classes
        # @return [Array] used crystal atom iterators
        def used_iterators
          return @_used_iterators if @_used_iterators

          lattices = links.reduce(Set.new) do |acc, (props, list)|
            list.empty? ? acc : (acc << props.lattice)
          end

          @_used_iterators = lattices.to_a.compact.map do |lattice|
            @generator.lattice_class(lattice).iterator
          end
        end

        # Combines used iterators for using them as parent classes
        # @return [String] the string that correspond to parent classes from which
        #   specie class instance will be inheritance in source code
        def iterator_classes_str
          class_names = used_iterators.map { |iter| "public #{iter.class_name}" }
          class_names.empty? ? '' : ", #{class_names.join(', ')}"
        end

        # Gets list of used iterator files
        # @return [Array] the array of file names
        def iterator_files
          used_iterators.map(&:file_name)
        end

        # Makes arguments string for static find method
        # @return [String] the arguments string of find method
        def find_arguments_str
          parents.size == 1 ? "#{parents.first.class_name} *target" : 'Atom *anchor'
        end

        # Makes arguments string for constructor method
        # @return [Array] the arguments string of constructor method
        def constructor_arguments_str
          constructor_arguments.map(&:join).join(', ')
        end

        # Makes arguments for constructor method
        # @return [Array] the arguments of constructor method
        def constructor_arguments
          [major_constructor_argument]
        end

        # Selects major constructor argument by number of specie parents
        # @return [Array] the first item is type and the second is variable name
        def major_constructor_argument
          parents_num = parents.size
          if parents_num == 0
            ['Atom **', 'atoms']
          elsif parents_num == 1
            ['ParentSpec *', 'parent']
          else # parents_num > 1
            ['ParentSpec **', 'parents']
          end
        end

        # Makes suffix of name which is used in name builder methods
        # @param [String] brackets_str the string which contain brackets and some
        #   additional params of specie in them
        # @return [String] the suffix of name
        # @example generating name
        #   '(ct: *, ct: i, cr: i)' => 'CTsiCRi'
        def name_suffixes(brackets_str)
          params_str = brackets_str.scan(/\((.+?)\)/).first.first
          params = params_str.scan(/(\w+): (.)/)
          strs = params.group_by(&:first).map do |k, gs|
            states = gs.map { |item| item.last == '*' ? 's' : item.last }.join
            "#{k.upcase}#{states}"
          end
          strs.sort
        end

        # Gets the specie class code generator
        # @param [Organizers::DependentSpec] dept_spec dependent specie the code
        #   generator of which will be got
        # @return [Specie]
        def specie_class(dept_spec)
          @generator.specie_class(dept_spec.name)
        end

        # Makes output directory path where generating file will be created
        # @param [String] root_dir see at #super same argument
        # @return [Pathname] the path to output directory
        # @override
        def out_dir_path(root_dir)
          super + outer_base_file
        end

        # The additional path for current instance
        # @return [String] the additional directories path
        # @override
        def additional_path
          'species'
        end
      end

    end
  end
end
